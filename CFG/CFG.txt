#TERMINALS
break  const  case  catch  continue  default  delete  else  false  finally  for  function  if  let  null  return  switch  throw  try  true  var  while  new  Error  (  )  {  }  [  ]  ;  =  +  -  *  /  %  <  >  &  ^  |  ?  !  \'  /*  */  \\  \"  \`  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  .  '  "  #  $  :  @  \  _  `  €  ,  „  †  ‡  ˆ  ‰  Š  ‹  Œ  Ž  ‘ ’  “  ”  •  –  —  ˜  ™  š  ›  œ  ž  Ÿ  ¡  ¢  £  ¤  ¥  ¦  §  ¨  ©  ª  «  ¬  ®  ¯  °  ±  ²  ³  ´  µ  ¶  ·  ¸  ¹  º  »  ¼  ½  ¾  ¿  À  Á  Â  Ã  Ä  Å  Æ  Ç  È  É  Ê  Ë  Ì  Í  Ï  Ð  Ñ  Ò  Ó  Ô  Õ  Ö  ×  Ø  Ù  Ú  Û  Ü  Ý  Þ  ß  à  á  â  ã  ä  å  æ  ç  è  é  ê  ë  ì  í  Î  ï  ð  ñ  ò  ó  ô  õ  ö  ÷  ø  ù  ú  û  ü  ý  þ  ÿ        
#VARIABLES
ASSIGNMENT_OP  COMPARISON_OP  BINARY_ARITHMETIC_OP  UNARY_ARITHMETIC_OP  BINARY_BITWISE_OP  UNARY_BITWISE_OP  BINARY_LOGICAL_OP  UNARY_LOGICAL_OP  BINARY_OP  UNARY_OP  SINGLE_INT  INT  BIGINT  FLOAT  NUMBER  ALPHABET  PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE  PRINTABLE_ASCII_WITHOUT_QUOTATION  PRINTABLE_ASCII_WITHOUT_FORMAT_HEAD  PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_HEAD  PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_HEAD  ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_HEAD  ASCII_WORD_WITHOUT_SINGLE_QUOTATION_HEAD  ASCII_WORD_WITHOUT_FORMAT_HEAD  PRINTABLE_ASCII_WITHOUT_QUOTATION_TAIL  PRINTABLE_ASCII_WITHOUT_FORMAT_TAIL  PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_TAIL  PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_TAIL  ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL  ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL  ASCII_WORD_WITHOUT_FORMAT_TAIL  ASCII_WORD  FORMAT_WORD  DOUBLE_QUOTE_STRING  SINGLE_QUOTE_STRING  FORMAT_STRING  BOOLEAN  STRING  VARIABLES_FIRST_CHAR  VARIABLES_SUFIX  VARIABLES  PARAMETER_LIST  FUNC_CALL  OBJ_ATTR_CALL  OBJ_FUNC_CALL  OBJ_CALL  PRIMITIVE  DATA  ARRAY_LIST  ARRAY  OBJ_ELMT  OBJ  LOGICAL_EXPRESSION  ARITHMETIC_EXPRESSION  STRING_EXPRESSION  EXPRESSION  ASSIGNMENT  DECLARATION_KEYWORD  DECLARATION  RETURN_STATEMENT  THROW_STATEMENT  STATEMENT  LINE  BODY_BLOCK  CONDITION  CONDITIONAL_BLOCK  ONLY_IF_STATEMENT  ELIF_STATEMENT  ELSE_STATEMENT  IF_STATEMENT  LOOP_LINE  LOOP_BLOCK  CONDITIONAL_LOOP_BLOCK  WHILE_STATEMENT  ARRAY_PARAM_LIST  ARRAY_PARAM  OBJECT_PARAM_ELMT  OBJECT_PARAM_LIST  OBJECT_PARAM  FOR_CONDITION  FOR_STATEMENT  PARAMETER_ELMT  PARAMETER_LIST  PARAMETER  FUNCTION  TRY_STATEMENT  ONLY_TRY_STATEMENT  CATCH_STATEMENT  FINALLY_STATEMENT  CASE_LINE  CASE_BLOCK  SWITCH_CASE  SWITCH_DEFAULT  SWITCH_BLOCK  SWITCH_STATEMENT  FUNCTION_LINE  FUNCTION_BLOCK  CODE  FUNCTION_IF_STATEMENT  FUNCTION_CONDITIONAL_BLOCK  FUNCTION_ONLY_IF_STATEMENT  FUNCTION_ELIF_STATEMENT  FUNCTION_ELSE_STATEMENT  FUNCTION_CONDITIONAL_BLOCK  FUNCTION_LOOP_LINE  FUNCTION_LOOP_BLOCK  FUNCTION_CONDITIONAL_LOOP_BLOCK  FUNCTION_WHILE_STATEMENT  FUNCTION_FOR_STATEMENT  FUNCTION_TRY_STATEMENT  FUNCTION_ONLY_TRY_STATEMENT  FUNCTION_CATCH_STATEMENT  FUNCTION_FINALLY_STATEMENT  FUNCTION_CASE_LINE  FUNCTION_CASE_BLOCK  FUNCTION_SWITCH_CASE  FUNCTION_SWITCH_DEFAULT  FUNCTION_SWITCH_BLOCK  FUNCTION_SWITCH_STATEMENT  MULTI_LINE_COMMENT  ASCII_WORD  BLANK  DECLARATION_ELMT  DECLARATION_LIST  ARGUMENT_LIST  PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_OPENCURLY_HEAD  PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_DOLLAR_HEAD  PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_OPENCURLY_TAIL  PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_DOLLAR_TAIL  FORMAT_WORD_HEAD  FORMAT_WORD_TAIL  OBJ_LIST  ARR_CALL  ARR_IDX  LOOP_IF_STATEMENT  LOOP_IF_STATEMENT  LOOP_CONDITIONAL_BLOCK  LOOP_ONLY_IF_STATEMENT  LOOP_ELIF_STATEMENT  LOOP_ELSE_STATEMENT  LOOP_TRY_STATEMENT  LOOP_ONLY_TRY_STATEMENT  LOOP_CATCH_STATEMENT  LOOP_FINALLY_STATEMENT  LOOP_CASE_LINE  LOOP_CASE_BLOCK  LOOP_SWITCH_CASE  LOOP_SWITCH_DEFAULT  LOOP_SWITCH_BLOCK  LOOP_SWITCH_STATEMENT  CONDITIONAL_EXPRESSION  CONST_DECLARATION  CONST_DECLARATION_ELMT  CONST_DECLARATION_LIST  ASSIGNED_EXPRESSION  TRY_LINE  TRY_BLOCK  LOOP_TRY_LINE  LOOP_TRY_BLOCK  FUNCTION_TRY_LINE  FUNCTION_TRY_BLOCK  ARRAY_KEY_LIST
#PRODUCTIONS
ASSIGNMENT_OP -> =  + =  - =  * =  / =  % =  * * =  < < =  > > =  > > > =  & =  ^ =  | =  & & =  | | =  ? ? =
COMPARISON_OP -> = =  ! =  = = =  ! = =  >  > =  <  < =
BINARY_ARITHMETIC_OP -> %  -  +  * *  /  *
UNARY_ARITHMETIC_OP -> + +  - -
BINARY_BITWISE_OP -> &  |  ^  < <  > >  > > >
UNARY_BITWISE_OP -> ~
BINARY_LOGICAL_OP -> & &  | |  COMPARISON_OP  ? ?
UNARY_LOGICAL_OP -> !
BINARY_OP -> ASSIGNMENT_OP  COMPARISON_OP  BINARY_ARITHMETIC_OP  BINARY_BITWISE_OP  BINARY_LOGICAL_OP
UNARY_OP -> UNARY_ARITHMETIC_OP  UNARY_BITWISE_OP  UNARY_LOGICAL_OP
SINGLE_INT -> 0  1  2  3  4  5  6  7  8  9
INT -> SINGLE_INT  INT INT
BIGINT -> INT n
FLOAT -> INT . INT  INT .  . INT
NUMBER -> INT  BIGINT  FLOAT
ALPHABET -> a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z
PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE -> ALPHABET  SINGLE_INT  \'  \"  \\  \`  !  #  %  &  (  )  *  +  -  /  :  ;  <  =  >  ?  @  [  ]  ^  _  |  ~  €  ,  „  …  †  ‡  ˆ  ‰  Š  ‹  Œ  Ž  ‘  ’  “  ”  •  –  —  ˜  ™  š  ›  œ  ž  Ÿ  ¡  ¢  £  ¤  ¥  ¦  §  ¨  ©  ª  «  ¬  ®  ¯  °  ±  ²  ³  ´  µ  ¶  ·  ¸  ¹  º  »  ¼  ½  ¾  ¿  À  Á  Â  Ã  Ä  Å  Æ  Ç  È  É  Ê  Ë  Ì  Í  Ï  Î  Ð  Ñ  Ò  Ó  Ô  Õ  Ö  ×  Ø  Ù  Ú  Û  Ü  Ý  Þ  ß  à  á  â  ã  ä  å  æ  ç  è  é  ê  ë  ì  í  Î  ï  ð  ñ  ò  ó  ô  õ  ö  ÷  ø  ù  ú  û  ü  ý  þ  ÿ  BLANK  }  .
PRINTABLE_ASCII_WITHOUT_QUOTATION -> PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE  \  $  {  `
PRINTABLE_ASCII_WITHOUT_FORMAT_HEAD -> PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE  "  '  \
PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_HEAD -> PRINTABLE_ASCII_WITHOUT_QUOTATION  '
PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_HEAD -> PRINTABLE_ASCII_WITHOUT_QUOTATION  "
PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_OPENCURLY_HEAD -> PRINTABLE_ASCII_WITHOUT_FORMAT_HEAD  $
PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_DOLLAR_HEAD -> PRINTABLE_ASCII_WITHOUT_FORMAT_HEAD  {
ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_HEAD -> PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_HEAD  ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_HEAD ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_HEAD
ASCII_WORD_WITHOUT_SINGLE_QUOTATION_HEAD -> PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_HEAD  ASCII_WORD_WITHOUT_SINGLE_QUOTATION_HEAD ASCII_WORD_WITHOUT_SINGLE_QUOTATION_HEAD
ASCII_WORD_WITHOUT_FORMAT_HEAD -> PRINTABLE_ASCII_WITHOUT_FORMAT_HEAD  ASCII_WORD_WITHOUT_FORMAT_HEAD ASCII_WORD_WITHOUT_FORMAT_HEAD
PRINTABLE_ASCII_WITHOUT_QUOTATION_TAIL -> PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE  $  {  `
PRINTABLE_ASCII_WITHOUT_FORMAT_TAIL -> PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE  "  '
PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_OPENCURLY_TAIL -> PRINTABLE_ASCII_WITHOUT_FORMAT_TAIL  $
PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_DOLLAR_TAIL -> PRINTABLE_ASCII_WITHOUT_FORMAT_TAIL  {
PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_TAIL -> PRINTABLE_ASCII_WITHOUT_QUOTATION_TAIL  '
PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_TAIL -> PRINTABLE_ASCII_WITHOUT_QUOTATION_TAIL  "
ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL -> PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_TAIL  ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL
ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL -> PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_TAIL  ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL
ASCII_WORD_WITHOUT_FORMAT_TAIL -> PRINTABLE_ASCII_WITHOUT_FORMAT_TAIL  ASCII_WORD_WITHOUT_FORMAT_TAIL ASCII_WORD_WITHOUT_FORMAT_TAIL
ASCII_WORD -> PRINTABLE_ASCII_WITHOUT_QUOTATION  "  '  ASCII_WORD ASCII_WORD
FORMAT_WORD_HEAD -> ASCII_WORD_WITHOUT_FORMAT_TAIL  $ { ASSIGNED_EXPRESSION }  ASCII_WORD_WITHOUT_FORMAT_HEAD  $ PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_OPENCURLY_HEAD  PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_DOLLAR_HEAD {  FORMAT_WORD_HEAD FORMAT_WORD_HEAD
FORMAT_WORD_TAIL -> ASCII_WORD_WITHOUT_FORMAT_TAIL  $ { ASSIGNED_EXPRESSION }  ASCII_WORD_WITHOUT_FORMAT_HEAD ASCII_WORD_WITHOUT_FORMAT_TAIL  $ PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_OPENCURLY_TAIL  PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_DOLLAR_TAIL {  FORMAT_WORD_TAIL FORMAT_WORD_TAIL
FORMAT_WORD -> FORMAT_WORD_TAIL  FORMAT_WORD_HEAD FORMAT_WORD  { FORMAT_WORD  FORMAT_WORD $  $  {
DOUBLE_QUOTE_STRING -> " ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_HEAD ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL "  " ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL "  " "
SINGLE_QUOTE_STRING -> ' ASCII_WORD_WITHOUT_SINGLE_QUOTATION_HEAD ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL '  ' ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL '  ' '
FORMAT_STRING -> ` FORMAT_WORD `  ` `
STRING -> DOUBLE_QUOTE_STRING  SINGLE_QUOTE_STRING  FORMAT_STRING
BOOLEAN -> true  false
VARIABLES_FIRST_CHAR -> ALPHABET  _  $
VARIABLES_SUFIX -> SINGLE_INT  VARIABLES_FIRST_CHAR  VARIABLES_SUFIX VARIABLES_SUFIX
VARIABLES -> VARIABLES_FIRST_CHAR  VARIABLES_FIRST_CHAR VARIABLES_SUFIX
ARRAY_LIST -> ASSIGNED_EXPRESSION  ,  ASSIGNED_EXPRESSION , ARRAY_LIST  , ARRAY_LIST  
ARRAY -> [ ARRAY_LIST ]
OBJ_ELMT -> VARIABLES  VARIABLES : ASSIGNED_EXPRESSION
OBJ_LIST -> OBJ_ELMT  OBJ_ELMT ,  OBJ_ELMT , OBJ_LIST
OBJ -> { OBJ_LIST }  { }
ARGUMENT_LIST -> ASSIGNED_EXPRESSION  ASSIGNED_EXPRESSION , ARGUMENT_LIST
FUNC_CALL -> VARIABLES ( ARGUMENT_LIST )  VARIABLES ( )
OBJ_ATTR_CALL -> VARIABLES  VARIABLES . OBJ_ATTR_CALL  VARIABLES ? . OBJ_ATTR_CALL
OBJ_FUNC_CALL -> OBJ_ATTR_CALL . FUNC_CALL  OBJ_ATTR_CALL ? . FUNC_CALL
OBJ_CALL -> OBJ_ATTR_CALL  OBJ_FUNC_CALL
ARR_IDX -> [ ASSIGNED_EXPRESSION ]  ARR_IDX ARR_IDX
ARR_CALL -> VARIABLES ARR_IDX  OBJ_ATTR_CALL ARR_IDX
PRIMITIVE -> BOOLEAN  NUMBER  STRING  ARRAY  OBJ  null
DATA -> PRIMITIVE  VARIABLES  FUNC_CALL  OBJ_CALL  ARR_CALL
LOGICAL_EXPRESSION -> EXPRESSION  LOGICAL_EXPRESSION BINARY_LOGICAL_OP LOGICAL_EXPRESSION  UNARY_LOGICAL_OP LOGICAL_EXPRESSION
ARITHMETIC_EXPRESSION -> EXPRESSION  ARITHMETIC_EXPRESSION BINARY_ARITHMETIC_OP ARITHMETIC_EXPRESSION  ARITHMETIC_EXPRESSION BINARY_BITWISE_OP ARITHMETIC_EXPRESSION  UNARY_ARITHMETIC_OP ARITHMETIC_EXPRESSION  BLANK UNARY_ARITHMETIC_OP ARITHMETIC_EXPRESSION  ARITHMETIC_EXPRESSION UNARY_ARITHMETIC_OP  ARITHMETIC_EXPRESSION UNARY_ARITHMETIC_OP BLANK  UNARY_BITWISE_OP ARITHMETIC_EXPRESSION
STRING_EXPRESSION -> STRING  ( STRING_EXPRESSION )  STRING_EXPRESSION + STRING_EXPRESSION
CONDITIONAL_EXPRESSION -> EXPRESSION ? ASSIGNED_EXPRESSION : ASSIGNED_EXPRESSION
EXPRESSION -> DATA  LOGICAL_EXPRESSION  ARITHMETIC_EXPRESSION  STRING_EXPRESSION  CONDITIONAL_EXPRESSION  ASSIGNMENT  ( EXPRESSION )  ( - EXPRESSION )  ( + EXPRESSION )  delete ASSIGNED_EXPRESSION
ASSIGNED_EXPRESSION -> EXPRESSION  function PARAMETER { FUNCTION_BLOCK }  function VARIABLES PARAMETER { FUNCTION_BLOCK }  ASSIGNED_EXPRESSION ? ASSIGNED_EXPRESSION : ASSIGNED_EXPRESSION  ASSIGNED_EXPRESSION , ASSIGNED_EXPRESSION  ( ASSIGNED_EXPRESSION )  ( - ASSIGNED_EXPRESSION )  ( + ASSIGNED_EXPRESSION )
ASSIGNMENT -> EXPRESSION ASSIGNMENT_OP ASSIGNED_EXPRESSION
CONST_DECLARATION_ELMT -> VARIABLES = ASSIGNED_EXPRESSION
CONST_DECLARATION_LIST -> CONST_DECLARATION_ELMT  CONST_DECLARATION_ELMT , CONST_DECLARATION_LIST
CONST_DECLARATION -> const CONST_DECLARATION_LIST
DECLARATION_KEYWORD -> let  var
DECLARATION_ELMT -> VARIABLES  VARIABLES = ASSIGNED_EXPRESSION
DECLARATION_LIST -> DECLARATION_ELMT  DECLARATION_ELMT , DECLARATION_LIST
DECLARATION -> DECLARATION_KEYWORD DECLARATION_LIST  CONST_DECLARATION
THROW_STATEMENT -> throw ASSIGNED_EXPRESSION  throw new Error ( ASSIGNED_EXPRESSION )
RETURN_STATEMENT -> return ASSIGNED_EXPRESSION  return
STATEMENT -> EXPRESSION  DECLARATION  THROW_STATEMENT
LINE -> IF_STATEMENT  WHILE_STATEMENT  FOR_STATEMENT  TRY_STATEMENT  SWITCH_STATEMENT  FUNCTION  STATEMENT ;  MULTI_LINE_COMMENT  ;
BODY_BLOCK -> LINE  BODY_BLOCK BODY_BLOCK  { BODY_BLOCK }  
MULTI_LINE_COMMENT -> /* ASCII_WORD */
CONDITION -> ( ASSIGNED_EXPRESSION )
CONDITIONAL_BLOCK -> CONDITION { BODY_BLOCK }  CONDITION LINE
ONLY_IF_STATEMENT -> if CONDITIONAL_BLOCK
ELIF_STATEMENT -> else ONLY_IF_STATEMENT  ELIF_STATEMENT ELIF_STATEMENT
ELSE_STATEMENT -> else { BODY_BLOCK }  else LINE
IF_STATEMENT -> ONLY_IF_STATEMENT  ONLY_IF_STATEMENT ELIF_STATEMENT  ONLY_IF_STATEMENT ELSE_STATEMENT  ONLY_IF_STATEMENT ELIF_STATEMENT ELSE_STATEMENT
LOOP_LINE -> LOOP_IF_STATEMENT  WHILE_STATEMENT  FOR_STATEMENT  LOOP_TRY_STATEMENT  LOOP_SWITCH_STATEMENT  FUNCTION  STATEMENT ;  MULTI_LINE_COMMENT  ;  break ;  continue ;
LOOP_BLOCK -> LOOP_LINE  LOOP_BLOCK LOOP_BLOCK  { LOOP_BLOCK }  
LOOP_IF_STATEMENT -> LOOP_ONLY_IF_STATEMENT  LOOP_ONLY_IF_STATEMENT LOOP_ELIF_STATEMENT  LOOP_ONLY_IF_STATEMENT LOOP_ELSE_STATEMENT  LOOP_ONLY_IF_STATEMENT LOOP_ELIF_STATEMENT LOOP_ELSE_STATEMENT
LOOP_CONDITIONAL_BLOCK -> CONDITION { LOOP_BLOCK }  CONDITION LOOP_LINE
LOOP_ONLY_IF_STATEMENT -> if LOOP_CONDITIONAL_BLOCK
LOOP_ELIF_STATEMENT -> else LOOP_ONLY_IF_STATEMENT  LOOP_ELIF_STATEMENT LOOP_ELIF_STATEMENT
LOOP_ELSE_STATEMENT -> else { LOOP_BLOCK }  else LOOP_LINE
LOOP_TRY_LINE -> LOOP_LINE
LOOP_TRY_BLOCK -> LOOP_TRY_LINE  LOOP_TRY_BLOCK LOOP_TRY_BLOCK  { LOOP_TRY_BLOCK }  
LOOP_TRY_STATEMENT -> LOOP_ONLY_TRY_STATEMENT LOOP_CATCH_STATEMENT  LOOP_ONLY_TRY_STATEMENT LOOP_CATCH_STATEMENT LOOP_FINALLY_STATEMENT  LOOP_ONLY_TRY_STATEMENT LOOP_FINALLY_STATEMENT
LOOP_ONLY_TRY_STATEMENT -> try { LOOP_TRY_BLOCK }
LOOP_CATCH_STATEMENT -> catch ( VARIABLES ) { LOOP_BLOCK }  catch { LOOP_BLOCK }
LOOP_FINALLY_STATEMENT -> finally { LOOP_BLOCK }
LOOP_CASE_LINE -> LOOP_LINE
LOOP_CASE_BLOCK -> LOOP_CASE_LINE  LOOP_CASE_BLOCK LOOP_CASE_BLOCK  { LOOP_CASE_BLOCK }  
LOOP_SWITCH_CASE -> case ASSIGNED_EXPRESSION : LOOP_CASE_BLOCK  LOOP_SWITCH_CASE LOOP_SWITCH_CASE
LOOP_SWITCH_DEFAULT -> default : LOOP_CASE_BLOCK
LOOP_SWITCH_BLOCK -> LOOP_SWITCH_CASE  LOOP_SWITCH_CASE LOOP_SWITCH_DEFAULT  
LOOP_SWITCH_STATEMENT -> switch ( ASSIGNED_EXPRESSION ) { LOOP_SWITCH_BLOCK }
CONDITIONAL_LOOP_BLOCK -> CONDITION { LOOP_BLOCK }  CONDITION LOOP_LINE
WHILE_STATEMENT -> while CONDITIONAL_LOOP_BLOCK  do LOOP_BLOCK while CONDITION ;  do LOOP_LINE while CONDITION ;
ARRAY_PARAM_LIST -> PARAMETER_ELMT  ,  PARAMETER_ELMT , ARRAY_PARAM_LIST  , ARRAY_PARAM_LIST  
ARRAY_PARAM -> [ ARRAY_PARAM_LIST ]
ARRAY_KEY_LIST -> ASSIGNED_EXPRESSION  ASSIGNED_EXPRESSION , ARRAY_KEY_LIST
OBJECT_PARAM_ELMT -> VARIABLES  VARIABLES : PARAMETER_ELMT  [ ARRAY_KEY_LIST ] : PARAMETER_ELMT
OBJECT_PARAM_LIST -> OBJECT_PARAM_ELMT  OBJECT_PARAM_ELMT ,  OBJECT_PARAM_ELMT , OBJECT_PARAM_LIST
OBJECT_PARAM -> { OBJECT_PARAM_LIST }  { }
PARAMETER_ELMT -> VARIABLES  VARIABLES = ASSIGNED_EXPRESSION  ARRAY_PARAM  OBJECT_PARAM
PARAMETER_LIST -> PARAMETER_ELMT  PARAMETER_ELMT , PARAMETER_LIST  PARAMETER_ELMT ,
PARAMETER -> ( PARAMETER_LIST )  ( )
FOR_CONDITION -> ( ASSIGNED_EXPRESSION ; ASSIGNED_EXPRESSION ; ASSIGNED_EXPRESSION )  ( DECLARATION ; ASSIGNED_EXPRESSION ; ASSIGNED_EXPRESSION )
FOR_STATEMENT -> for FOR_CONDITION { LOOP_BLOCK }  for FOR_CONDITION LOOP_LINE
FUNCTION -> function VARIABLES PARAMETER { FUNCTION_BLOCK }  function VARIABLES PARAMETER ;
FUNCTION_BLOCK -> FUNCTION_LINE  FUNCTION_BLOCK FUNCTION_BLOCK  { FUNCTION_BLOCK }  
FUNCTION_LINE -> MULTI_LINE_COMMENT  FUNCTION_IF_STATEMENT  FUNCTION_WHILE_STATEMENT  FUNCTION_FOR_STATEMENT  FUNCTION_TRY_STATEMENT  FUNCTION_SWITCH_STATEMENT  FUNCTION  STATEMENT ;  RETURN_STATEMENT ;  ;
FUNCTION_IF_STATEMENT -> FUNCTION_ONLY_IF_STATEMENT  FUNCTION_ONLY_IF_STATEMENT FUNCTION_ELIF_STATEMENT  FUNCTION_ONLY_IF_STATEMENT FUNCTION_ELSE_STATEMENT  FUNCTION_ONLY_IF_STATEMENT FUNCTION_ELIF_STATEMENT FUNCTION_ELSE_STATEMENT
FUNCTION_CONDITIONAL_BLOCK -> CONDITION { FUNCTION_BLOCK }  CONDITION FUNCTION_LINE
FUNCTION_ONLY_IF_STATEMENT -> if FUNCTION_CONDITIONAL_BLOCK
FUNCTION_ELIF_STATEMENT -> else FUNCTION_ONLY_IF_STATEMENT  FUNCTION_ELIF_STATEMENT FUNCTION_ELIF_STATEMENT
FUNCTION_ELSE_STATEMENT -> else { FUNCTION_BLOCK }  else FUNCTION_LINE
FUNCTION_LOOP_LINE -> FUNCTION_LINE  break ;  continue ;
FUNCTION_LOOP_BLOCK -> FUNCTION_LOOP_LINE  FUNCTION_LOOP_BLOCK FUNCTION_LOOP_BLOCK  { FUNCTION_LOOP_BLOCK }  
FUNCTION_CONDITIONAL_LOOP_BLOCK -> CONDITION { FUNCTION_LOOP_BLOCK }  CONDITION FUNCTION_LOOP_LINE
FUNCTION_WHILE_STATEMENT -> while FUNCTION_CONDITIONAL_LOOP_BLOCK  do FUNCTION_LOOP_BLOCK while CONDITION ;  do FUNCTION_LOOP_LINE while CONDITION ;
FUNCTION_FOR_STATEMENT -> for FOR_CONDITION { FUNCTION_LOOP_BLOCK }  for FOR_CONDITION FUNCTION_LOOP_LINE
FUNCTION_TRY_LINE -> FUNCTION_LINE
FUNCTION_TRY_BLOCK -> FUNCTION_TRY_LINE  FUNCTION_TRY_BLOCK FUNCTION_TRY_BLOCK  { FUNCTION_TRY_BLOCK }  
FUNCTION_TRY_STATEMENT -> FUNCTION_ONLY_TRY_STATEMENT FUNCTION_CATCH_STATEMENT  FUNCTION_ONLY_TRY_STATEMENT FUNCTION_CATCH_STATEMENT FUNCTION_FINALLY_STATEMENT  FUNCTION_ONLY_TRY_STATEMENT FUNCTION_FINALLY_STATEMENT
FUNCTION_ONLY_TRY_STATEMENT -> try { FUNCTION_TRY_BLOCK }
FUNCTION_CATCH_STATEMENT -> catch ( VARIABLES ) { FUNCTION_BLOCK }  catch { FUNCTION_BLOCK }
FUNCTION_FINALLY_STATEMENT -> finally { FUNCTION_BLOCK }
FUNCTION_CASE_LINE -> FUNCTION_LINE  break ;
FUNCTION_CASE_BLOCK -> FUNCTION_CASE_LINE  FUNCTION_CASE_BLOCK FUNCTION_CASE_BLOCK  { FUNCTION_CASE_BLOCK }  
FUNCTION_SWITCH_CASE -> case ASSIGNED_EXPRESSION : FUNCTION_CASE_BLOCK  FUNCTION_SWITCH_CASE FUNCTION_SWITCH_CASE
FUNCTION_SWITCH_DEFAULT -> default : FUNCTION_CASE_BLOCK
FUNCTION_SWITCH_BLOCK -> FUNCTION_SWITCH_CASE  FUNCTION_SWITCH_CASE FUNCTION_SWITCH_DEFAULT  
FUNCTION_SWITCH_STATEMENT -> switch ( ASSIGNED_EXPRESSION ) { FUNCTION_SWITCH_BLOCK }
TRY_LINE -> LINE
TRY_BLOCK -> TRY_LINE  TRY_BLOCK TRY_BLOCK  { TRY_BLOCK }  
TRY_STATEMENT -> ONLY_TRY_STATEMENT CATCH_STATEMENT  ONLY_TRY_STATEMENT CATCH_STATEMENT FINALLY_STATEMENT  ONLY_TRY_STATEMENT FINALLY_STATEMENT
ONLY_TRY_STATEMENT -> try { TRY_BLOCK }
CATCH_STATEMENT -> catch ( VARIABLES ) { BODY_BLOCK }  catch { BODY_BLOCK }
FINALLY_STATEMENT -> finally { BODY_BLOCK }
CASE_LINE -> LINE  break ;
CASE_BLOCK -> CASE_LINE  CASE_BLOCK CASE_BLOCK  { CASE_BLOCK }  
SWITCH_CASE -> case ASSIGNED_EXPRESSION : CASE_BLOCK  SWITCH_CASE SWITCH_CASE
SWITCH_DEFAULT -> default : CASE_BLOCK
SWITCH_BLOCK -> SWITCH_CASE  SWITCH_CASE SWITCH_DEFAULT  
SWITCH_STATEMENT -> switch ( ASSIGNED_EXPRESSION ) { SWITCH_BLOCK }
CODE -> BODY_BLOCK