#TERMINALS
break  const  case  catch  continue  default  delete  else  false  finally  for  function  if  let  null  return  switch  throw  try  true  var  while  new  Error  (  )  {  }  [  ]  ;  =  +  -  *  /  %  <  >  &  ^  |  ?  !  \'  /*  */  \\  \"  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  .  '  "  #  $  :  @  \  _  `  €  ,  „  †  ‡  ˆ  ‰  Š  ‹  Œ  Ž  ‘ ’  “  ”  •  –  —  ˜  ™  š  ›  œ  ž  Ÿ  ¡  ¢  £  ¤  ¥  ¦  §  ¨  ©  ª  «  ¬  ®  ¯  °  ±  ²  ³  ´  µ  ¶  ·  ¸  ¹  º  »  ¼  ½  ¾  ¿  À  Á  Â  Ã  Ä  Å  Æ  Ç  È  É  Ê  Ë  Ì  Í  Ï  Ð  Ñ  Ò  Ó  Ô  Õ  Ö  ×  Ø  Ù  Ú  Û  Ü  Ý  Þ  ß  à  á  â  ã  ä  å  æ  ç  è  é  ê  ë  ì  í  Î  ï  ð  ñ  ò  ó  ô  õ  ö  ÷  ø  ù  ú  û  ü  ý  þ  ÿ        
#VARIABLES
ASSIGNMENT_OP  COMPARISON_OP  BINARY_ARITHMETIC_OP  UNARY_ARITHMETIC_OP  BINARY_BITWISE_OP  UNARY_BITWISE_OP  BINARY_LOGICAL_OP  UNARY_LOGICAL_OP  BINARY_OP  UNARY_OP  SINGLE_INT  INT  BIGINT  FLOAT  NUMBER  ALPHABET  PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE  PRINTABLE_ASCII_WITHOUT_QUOTATION  PRINTABLE_ASCII_WITHOUT_QUOTATION_HEAD  PRINTABLE_ASCII_WITHOUT_FORMAT_HEAD  PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_HEAD  PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_HEAD  ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_HEAD  ASCII_WORD_WITHOUT_SINGLE_QUOTATION_HEAD  ASCII_WORD_WITHOUT_FORMAT_HEAD  PRINTABLE_ASCII_WITHOUT_QUOTATION_TAIL  PRINTABLE_ASCII_WITHOUT_FORMAT_TAIL  PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_TAIL  PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_TAIL  ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL  ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL  ASCII_WORD_WITHOUT_FORMAT_TAIL  ASCII_WORD  FORMAT_WORD  DOUBLE_QUOTE_STRING  SINGLE_QUOTE_STRING  FORMAT_STRING  BOOLEAN  STRING  VARIABLES_FIRST_CHAR  VARIABLES_SUFIX  VARIABLES  PARAMETER_LIST  FUNC_CALL  OBJ_ATTR_CALL  OBJ_FUNC_CALL  OBJ_CALL  PRIMITIVE  DATA  ARRAY_LIST  ARRAY  OBJ_ELMT  OBJ  LOGICAL_EXPRESSION  ARITHMETIC_EXPRESSION  STRING_EXPRESSION  EXPRESSION  VAR_ASSIGNMENT  OBJ_ASSIGNMENT  ASSIGNMENT  DECLARATION_KEYWORD  DECLARATION  DELETE_STATEMENT  RETURN_STATEMENT  THROW_STATEMENT  STATEMENT  LINE  BODY_BLOCK  CONDITION  CONDITIONAL_BLOCK  ONLY_IF_STATEMENT  ELIF_STATEMENT  ELSE_STATEMENT  IF_STATEMENT  LOOP_LINE  LOOP_BLOCK  CONDITIONAL_LOOP_BLOCK  WHILE_STATEMENT  ARRAY_PARAM_LIST  ARRAY_PARAM  OBJECT_PARAM_ELMT  OBJECT_PARAM_LIST  OBJECT_PARAM  FOR_CONDITION  FOR_STATEMENT  PARAMETER_ELMT  PARAMETER_LIST  PARAMETER  FUNCTION  TRY_STATEMENT  ONLY_TRY_STATEMENT  CATCH_STATEMENT  FINALLY_STATEMENT  CASE_LINE  CASE_BLOCK  SWITCH_CASE  SWITCH_DEFAULT  SWITCH_BLOCK  SWITCH_STATEMENT  FUNCTION_LINE  FUNCTION_BLOCK  CODE  FUNCTION_IF_STATEMENT  FUNCTION_CONDITIONAL_BLOCK  FUNCTION_ONLY_IF_STATEMENT  FUNCTION_ELIF_STATEMENT  FUNCTION_ELSE_STATEMENT  FUNCTION_CONDITIONAL_BLOCK  FUNCTION_LOOP_LINE  FUNCTION_LOOP_BLOCK  FUNCTION_CONDITIONAL_LOOP_BLOCK  FUNCTION_WHILE_STATEMENT  FUNCTION_FOR_STATEMENT  FUNCTION_TRY_STATEMENT  FUNCTION_ONLY_TRY_STATEMENT  FUNCTION_CATCH_STATEMENT  FUNCTION_FINALLY_STATEMENT  FUNCTION_CASE_LINE  FUNCTION_CASE_BLOCK  FUNCTION_SWITCH_CASE  FUNCTION_SWITCH_DEFAULT  FUNCTION_SWITCH_BLOCK  FUNCTION_SWITCH_STATEMENT  MULTI_LINE_COMMENT  ASCII_WORD  BLANK  DECLARATION_ELMT  DECLARATION_LIST  PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_OPENCURLY  PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_DOLLAR  FORMAT_WORD_HEAD  FORMAT_WORD_TAIL
#PRODUCTIONS
ASSIGNMENT_OP -> =  + =  - =  * =  / =   % =  * * =  < < =  > > =  > > > =  & =  ^ =  | =  & & =  | | =  ? ? =
COMPARISON_OP -> = =  ! =  = = =  ! = =  >  > =  <  < =
BINARY_ARITHMETIC_OP -> %  -  +  * *  /  *
UNARY_ARITHMETIC_OP -> + +  - -
BINARY_BITWISE_OP -> &  |  ^  < <  < <  > > >
UNARY_BITWISE_OP -> ~
BINARY_LOGICAL_OP -> & &  | |  COMPARISON_OP
UNARY_LOGICAL_OP -> !
BINARY_OP -> ASSIGNMENT_OP  COMPARISON_OP  BINARY_ARITHMETIC_OP  BINARY_BITWISE_OP  BINARY_LOGICAL_OP
UNARY_OP -> UNARY_ARITHMETIC_OP  UNARY_BITWISE_OP  UNARY_LOGICAL_OP
SINGLE_INT -> 0  1  2  3  4  5  6  7  8  9
INT -> SINGLE_INT  INT INT
BIGINT -> INT n
FLOAT -> INT . INT  INT .  . INT
NUMBER -> INT  BIGINT  FLOAT
ALPHABET -> a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z
PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE -> ALPHABET  SINGLE_INT  \'  \"  \\  !  #  %  &  (  )  *  +  -  /  :  ;  <  =  >  ?  @  [  ]  ^  _  |  ~  €  ,  „  …  †  ‡  ˆ  ‰  Š  ‹  Œ  Ž  ‘  ’  “  ”  •  –  —  ˜  ™  š  ›  œ  ž  Ÿ  ¡  ¢  £  ¤  ¥  ¦  §  ¨  ©  ª  «  ¬  ®  ¯  °  ±  ²  ³  ´  µ  ¶  ·  ¸  ¹  º  »  ¼  ½  ¾  ¿  À  Á  Â  Ã  Ä  Å  Æ  Ç  È  É  Ê  Ë  Ì  Í  Ï  Î  Ð  Ñ  Ò  Ó  Ô  Õ  Ö  ×  Ø  Ù  Ú  Û  Ü  Ý  Þ  ß  à  á  â  ã  ä  å  æ  ç  è  é  ê  ë  ì  í  Î  ï  ð  ñ  ò  ó  ô  õ  ö  ÷  ø  ù  ú  û  ü  ý  þ  ÿ  \  BLANK
PRINTABLE_ASCII_WITHOUT_QUOTATION -> PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE  \  $  {  }  `
PRINTABLE_ASCII_WITHOUT_QUOTATION_HEAD -> PRINTABLE_ASCII_WITHOUT_QUOTATION
PRINTABLE_ASCII_WITHOUT_FORMAT_HEAD -> PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE  "  '  \  }
PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_HEAD -> PRINTABLE_ASCII_WITHOUT_QUOTATION  '
PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_HEAD -> PRINTABLE_ASCII_WITHOUT_QUOTATION  "
PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_OPENCURLY -> PRINTABLE_ASCII_WITHOUT_FORMAT_TAIL  $
PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_DOLLAR -> PRINTABLE_ASCII_WITHOUT_FORMAT_TAIL  {
ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_HEAD -> PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_HEAD  ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_HEAD ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_HEAD
ASCII_WORD_WITHOUT_SINGLE_QUOTATION_HEAD -> PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_HEAD  ASCII_WORD_WITHOUT_SINGLE_QUOTATION_HEAD ASCII_WORD_WITHOUT_SINGLE_QUOTATION_HEAD
ASCII_WORD_WITHOUT_FORMAT_HEAD -> PRINTABLE_ASCII_WITHOUT_FORMAT_HEAD  ASCII_WORD_WITHOUT_FORMAT_HEAD ASCII_WORD_WITHOUT_FORMAT_HEAD
PRINTABLE_ASCII_WITHOUT_QUOTATION_TAIL -> PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE  $  {  }
PRINTABLE_ASCII_WITHOUT_FORMAT_TAIL -> PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_ESCAPE  "  '  }
PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_TAIL -> PRINTABLE_ASCII_WITHOUT_QUOTATION_TAIL  '  `
PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_TAIL -> PRINTABLE_ASCII_WITHOUT_QUOTATION_TAIL  "  `
ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL -> PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION_TAIL  ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL
ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL -> PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION_TAIL  ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL
ASCII_WORD_WITHOUT_FORMAT_TAIL -> PRINTABLE_ASCII_WITHOUT_FORMAT_TAIL  ASCII_WORD_WITHOUT_FORMAT_TAIL ASCII_WORD_WITHOUT_FORMAT_TAIL
ASCII_WORD -> PRINTABLE_ASCII_WITHOUT_QUOTATION  "  '  ASCII_WORD ASCII_WORD
FORMAT_WORD_HEAD -> ASCII_WORD_WITHOUT_FORMAT_TAIL  $ { VARIABLES }  ASCII_WORD_WITHOUT_FORMAT_HEAD  $ PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_OPENCURLY  PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_DOLLAR {  { FORMAT_WORD_HEAD  FORMAT_WORD_HEAD $  $  {  FORMAT_WORD_HEAD FORMAT_WORD_HEAD
FORMAT_WORD_TAIL -> ASCII_WORD_WITHOUT_FORMAT_TAIL  $ { VARIABLES }  ASCII_WORD_WITHOUT_FORMAT_HEAD ASCII_WORD_WITHOUT_FORMAT_TAIL  $ PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_OPENCURLY  PRINTABLE_ASCII_WITHOUT_FORMAT_WITHOUT_DOLLAR {  { FORMAT_WORD_TAIL  FORMAT_WORD_TAIL $  $  {  FORMAT_WORD_TAIL FORMAT_WORD_TAIL
FORMAT_WORD -> FORMAT_WORD_TAIL  FORMAT_WORD_HEAD FORMAT_WORD_TAIL
DOUBLE_QUOTE_STRING -> " ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_HEAD ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL "  " ASCII_WORD_WITHOUT_DOUBLE_QUOTATION_TAIL "  " "
SINGLE_QUOTE_STRING -> ' ASCII_WORD_WITHOUT_SINGLE_QUOTATION_HEAD ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL '  ' ASCII_WORD_WITHOUT_SINGLE_QUOTATION_TAIL '  ' '
FORMAT_STRING -> ` FORMAT_WORD `  ` `
BOOLEAN -> true  false
STRING -> DOUBLE_QUOTE_STRING  SINGLE_QUOTE_STRING  FORMAT_STRING
VARIABLES_FIRST_CHAR -> ALPHABET  _  $
VARIABLES_SUFIX -> NUMBER  VARIABLES_FIRST_CHAR  VARIABLES_SUFIX VARIABLES_SUFIX
VARIABLES -> VARIABLES_FIRST_CHAR  VARIABLES_FIRST_CHAR VARIABLES_SUFIX
ARRAY_LIST -> EXPRESSION  ,  EXPRESSION , ARRAY_LIST  , ARRAY_LIST
ARRAY -> [ ARRAY_LIST ]  [ ]
OBJ_ELMT -> VARIABLES  VARIABLES : EXPRESSION  VARIABLES : FUNCTION
OBJ_LIST -> OBJ_ELMT  OBJ_ELMT ,  OBJ_ELMT , OBJ_LIST
OBJ -> { OBJ_ELMT }  { }
ARGUMENT_LIST -> EXPRESSION  EXPRESSION , ARGUMENT_LIST
FUNC_CALL -> VARIABLES ( ARGUMENT_LIST )
OBJ_ATTR_CALL -> VARIABLES  VARIABLES . OBJ_ATTR_CALL
OBJ_FUNC_CALL -> OBJ_ATTR_CALL . FUNC_CALL
OBJ_CALL -> OBJ_ATTR_CALL  OBJ_FUNC_CALL
PRIMITIVE -> BOOLEAN  NUMBER  STRING  ARRAY  OBJ  null
DATA -> PRIMITIVE  VARIABLES  FUNC_CALL  OBJ_CALL
LOGICAL_EXPRESSION -> EXPRESSION  LOGICAL_EXPRESSION BINARY_LOGICAL_OP LOGICAL_EXPRESSION  UNARY_LOGICAL_OP LOGICAL_EXPRESSION
ARITHMETIC_EXPRESSION -> EXPRESSION  ARITHMETIC_EXPRESSION BINARY_ARITHMETIC_OP ARITHMETIC_EXPRESSION  ARITHMETIC_EXPRESSION BINARY_BITWISE_OP ARITHMETIC_EXPRESSION  UNARY_ARITHMETIC_OP VARIABLES  VARIABLES UNARY_ARITHMETIC_OP  UNARY_BITWISE_OP ARITHMETIC_EXPRESSION
STRING_EXPRESSION -> STRING  ( STRING_EXPRESSION )  STRING_EXPRESSION + STRING_EXPRESSION
CONDITIONAL_EXPRESSION -> EXPRESSION ? EXPRESSION : EXPRESSION
EXPRESSION -> DATA  LOGICAL_EXPRESSION  ARITHMETIC_EXPRESSION  STRING_EXPRESSION  CONDITIONAL_EXPRESSION  ASSIGNMENT  ( EXPRESSION )  ( - EXPRESSION )  ( + EXPRESSION )
VAR_ASSIGNMENT ->  VARIABLES ASSIGNMENT_OP EXPRESSION
OBJ_ASSIGNMENT -> OBJ_ATTR_CALL ASSIGNMENT_OP EXPRESSION
EXPRESSION_ASSIGNMENT -> EXPRESSION ASSIGNMENT_OP EXPRESSION
ASSIGNMENT -> VAR_ASSIGNMENT  OBJ_ASSIGNMENT  EXPRESSION_ASSIGNMENT
DECLARATION_KEYWORD -> let  var  const
DECLARATION_ELMT -> VARIABLES  VARIABLES = EXPRESSION
DECLARATION_LIST -> DECLARATION_ELMT  DECLARATION_ELMT , DECLARATION_LIST
DECLARATION -> DECLARATION_KEYWORD DECLARATION_LIST
DELETE_STATEMENT -> delete EXPRESSION
THROW_STATEMENT -> throw EXPRESSION  throw new Error ( EXPRESSION )
RETURN_STATEMENT -> return EXPRESSION
STATEMENT -> EXPRESSION  DECLARATION  DELETE_STATEMENT  THROW_STATEMENT
LINE -> IF_STATEMENT  WHILE_STATEMENT  FOR_STATEMENT  TRY_STATEMENT  SWITCH_STATEMENT  FUNCTION  STATEMENT ;  MULTI_LINE_COMMENT  ;
BODY_BLOCK -> LINE  BODY_BLOCK BODY_BLOCK  { BODY_BLOCK }
MULTI_LINE_COMMENT -> /* ASCII_WORD */
CONDITION -> ( EXPRESSION )
CONDITIONAL_BLOCK -> CONDITION { BODY_BLOCK }  CONDITION LINE
ONLY_IF_STATEMENT -> if CONDITIONAL_BLOCK
ELIF_STATEMENT -> else IF_STATEMENT  ELIF_STATEMENT ELIF_STATEMENT
ELSE_STATEMENT -> else STATEMENT  else BODY_BLOCK
IF_STATEMENT -> ONLY_IF_STATEMENT  ONLY_IF_STATEMENT ELIF_STATEMENT  ONLY_IF_STATEMENT ELSE_STATEMENT  ONLY_IF_STATEMENT ELIF_STATEMENT ELSE_STATEMENT
LOOP_LINE -> LINE  break ;  continue ;
LOOP_BLOCK -> LOOP_LINE  LOOP_BLOCK LOOP_BLOCK  { LOOP_BLOCK }
CONDITIONAL_LOOP_BLOCK -> CONDITION { LOOP_BLOCK }  CONDITION LOOP_LINE
WHILE_STATEMENT -> while CONDITIONAL_LOOP_BLOCK  do LOOP_BLOCK while CONDITION  do LOOP_LINE while CONDITION
ARRAY_PARAM_LIST -> PARAMETER_ELMT  ,  PARAMETER_ELMT , ARRAY_PARAM_LIST  , ARRAY_PARAM_LIST
ARRAY_PARAM -> [ ARRAY_PARAM_ELMT ]
OBJECT_PARAM_ELMT -> VARIABLES  VARIABLES : PARAMETER_ELMT
OBJECT_PARAM_LIST -> OBJECT_PARAM_ELMT  OBJECT_PARAM_ELMT ,  OBJECT_PARAM_ELMT , OBJECT_PARAM_LIST
OBJECT_PARAM -> { OBJECT_PARAM_ELMT }
FOR_CONDITION -> ( EXPRESSION ; EXPRESSION ; EXPRESSION )  ( DECLARATION ; EXPRESSION ; EXPRESSION )
FOR_STATEMENT -> for FOR_CONDITION BODY_BLOCK
PARAMETER_ELMT -> VARIABLES  VARIABLES = EXPRESSION  VARIABLES = FUNCTION  ARRAY_PARAM  OBJECT_PARAM
PARAMETER_LIST -> PARAMETER_ELMT  PARAMETER_ELMT , PARAMETER_LIST
PARAMETER -> ( PARAMETER_LIST )
FUNCTION -> function VARIABLES PARAMETER { FUNCTION_BLOCK }  function VARIABLES PARAMETER ;
FUNCTION_BLOCK -> FUNCTION_LINE  FUNCTION_BLOCK FUNCTION_BLOCK  { FUNCTION_BLOCK }
FUNCTION_LINE -> MULTI_LINE_COMMENT  FUNCTION_IF_STATEMENT  FUNCTION_WHILE_STATEMENT  FUNCTION_FOR_STATEMENT  FUNCTION_TRY_STATEMENT  FUNCTION_SWITCH_STATEMENT  FUNCTION  STATEMENT ;  RETURN_STATEMENT ;  ;
TRY_STATEMENT -> ONLY_TRY_STATEMENT CATCH_STATEMENT  ONLY_TRY_STATEMENT CATCH_STATEMENT FINALLY_STATEMENT  ONLY_TRY_STATEMENT FINALLY_STATEMENT
ONLY_TRY_STATEMENT -> try { BODY_BLOCK }
CATCH_STATEMENT -> catch ( VARIABLES ) { BODY_BLOCK }  catch { BODY_BLOCK }
FINALLY_STATEMENT -> finally { BODY_BLOCK }
CASE_LINE -> LINE  break ;
CASE_BLOCK -> CASE_LINE  CASE_BLOCK CASE_BLOCK  { CASE_BLOCK }
SWITCH_CASE -> case EXPRESSION : CASE_BLOCK  SWITCH_CASE SWITCH_CASE
SWITCH_DEFAULT -> default : CASE_BLOCK
SWITCH_BLOCK -> SWITCH_CASE  SWITCH_CASE SWITCH_DEFAULT
SWITCH_STATEMENT -> switch ( EXPRESSION ) { SWITCH_BLOCK }
FUNCTION_IF_STATEMENT -> FUNCTION_ONLY_IF_STATEMENT  FUNCTION_ONLY_IF_STATEMENT FUNCTION_ELIF_STATEMENT  FUNCTION_ONLY_IF_STATEMENT FUNCTION_ELSE_STATEMENT  FUNCTION_ONLY_IF_STATEMENT FUNCTION_ELIF_STATEMENT FUNCTION_ELSE_STATEMENT
FUNCTION_CONDITIONAL_BLOCK -> CONDITION { FUNCTION_BLOCK }  CONDITION FUNCTION_LINE
FUNCTION_ONLY_IF_STATEMENT -> if FUNCTION_CONDITIONAL_BLOCK
FUNCTION_ELIF_STATEMENT -> else FUNCTION_IF_STATEMENT  FUNCTION_ELIF_STATEMENT FUNCTION_ELIF_STATEMENT
FUNCTION_ELSE_STATEMENT -> else FUNCTION_STATEMENT  else FUNCTION_BLOCK
FUNCTION_CONDITIONAL_BLOCK -> CONDITION { FUNCTION_BLOCK }  CONDITION FUNCTION_LINE
FUNCTION_LOOP_LINE -> FUNCTION_LINE  break ;  continue ;
FUNCTION_LOOP_BLOCK -> FUNCTION_LOOP_LINE  FUNCTION_LOOP_BLOCK FUNCTION_LOOP_BLOCK  { FUNCTION_LOOP_BLOCK }
FUNCTION_CONDITIONAL_LOOP_BLOCK -> CONDITION { FUNCTION_LOOP_BLOCK }  CONDITION FUNCTION_LOOP_LINE
FUNCTION_WHILE_STATEMENT -> while FUNCTION_CONDITIONAL_LOOP_BLOCK  do FUNCTION_LOOP_BLOCK while CONDITION  do FUNCTION_LOOP_LINE while CONDITION
FUNCTION_FOR_STATEMENT -> for FOR_CONDITION FUNCTION_BLOCK
FUNCTION_TRY_STATEMENT -> FUNCTION_ONLY_TRY_STATEMENT FUNCTION_CATCH_STATEMENT  FUNCTION_ONLY_TRY_STATEMENT FUNCTION_CATCH_STATEMENT FUNCTION_FINALLY_STATEMENT  FUNCTION_ONLY_TRY_STATEMENT FUNCTION_FINALLY_STATEMENT
FUNCTION_ONLY_TRY_STATEMENT -> try { FUNCTION_BLOCK }
FUNCTION_CATCH_STATEMENT -> catch ( VARIABLES ) { FUNCTION_BLOCK }  catch { FUNCTION_BLOCK }
FUNCTION_FINALLY_STATEMENT -> finally { FUNCTION_BLOCK }
FUNCTION_CASE_LINE -> FUNCTION_LINE  break ;
FUNCTION_CASE_BLOCK -> FUNCTION_CASE_LINE  FUNCTION_CASE_BLOCK FUNCTION_CASE_BLOCK  { FUNCTION_CASE_BLOCK }
FUNCTION_SWITCH_CASE -> case EXPRESSION : FUNCTION_CASE_BLOCK  FUNCTION_SWITCH_CASE FUNCTION_SWITCH_CASE
FUNCTION_SWITCH_DEFAULT -> default : FUNCTION_CASE_BLOCK
FUNCTION_SWITCH_BLOCK -> FUNCTION_SWITCH_CASE  FUNCTION_SWITCH_CASE FUNCTION_SWITCH_DEFAULT
FUNCTION_SWITCH_STATEMENT -> switch ( EXPRESSION ) { FUNCTION_SWITCH_BLOCK }
CODE -> BODY_BLOCK