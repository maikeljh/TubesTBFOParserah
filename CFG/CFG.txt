#TERMINALS
break  const  case  catch  continue  default  delete  else  false  finally  for  function  if  let  null  return  switch  throw  try  true  var  while  Error  (  )  {  }  [  ]  ;  =  +  -  *  /  %  <  >  &  ^  |  ?  !  \'  \\  \"  a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z  .  '  "  #  $  :  @  \  _  `  €  ,  „  †  ‡  ˆ  ‰  Š  ‹  Œ  Ž  ‘ ’  “  ”  •  –  —  ˜  ™  š  ›  œ  ž  Ÿ  ¡  ¢  £  ¤  ¥  ¦  §  ¨  ©  ª  «  ¬  ®  ¯  °  ±  ²  ³  ´  µ  ¶  ·  ¸  ¹  º  »  ¼  ½  ¾  ¿  À  Á  Â  Ã  Ä  Å  Æ  Ç  È  É  Ê  Ë  Ì  Í  Ï  Ð  Ñ  Ò  Ó  Ô  Õ  Ö  ×  Ø  Ù  Ú  Û  Ü  Ý  Þ  ß  à  á  â  ã  ä  å  æ  ç  è  é  ê  ë  ì  í  Î  ï  ð  ñ  ò  ó  ô  õ  ö  ÷  ø  ù  ú  û  ü  ý  þ  ÿ   
#VARIABLES
BLANK  ASSIGNMENT_OP  COMPARISON_OP  BINARY_ARITHMETIC_OP  UNARY_ARITHMETIC_OP  BINARY_BITWISE_OP  UNARY_BITWISE_OP  BINARY_LOGICAL_OP  UNARY_LOGICAL_OP  BINARY_OP  UNARY_OP  SINGLE_INT  INT  BIGINT  FLOAT  NUMBER  ALPHABET  PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_FORMAT  PRINTABLE_ASCII_WITHOUT_QUOTATION  PRINTABLE_ASCII_WITHOUT_FORMAT  PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION  PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION  ASCII_WORD_WITHOUT_DOUBLE_QUOTATION  ASCII_WORD_WITHOUT_SINGLE_QUOTATION  ASCII_WORD_WITHOUT_FORMAT  FORMAT_WORD  DOUBLE_QUOTE_STRING  SINGLE_QUOTE_STRING  FORMAT_STRING  BOOLEAN  STRING  VARIABLES_FIRST_CHAR  VARIABLES_SUFIX  VARIABLES  PARAMETER_LIST  FUNC_CALL  OBJ_ATTR_CALL  OBJ_FUNC_CALL  OBJ_CALL  PRIMITIVE  DATA  ARRAY_LIST  ARRAY  OBJ_ELMT  OBJ  LOGICAL_EXPRESSION  ARITHMETIC_EXPRESSION  STRING_EXPRESSION  EXPRESSION  VAR_ASSIGNMENT  OBJ_ASSIGNMENT  ASSIGNMENT  DECLARATION_KEYWORD  DECLARATION  DELETE_STATEMENT  RETURN_STATEMENT  THROW_STATEMENT  STATEMENT  LINE  BODY_BLOCK  CONDITION  CONDITIONAL_BLOCK  ONLY_IF_STATEMENT  ELIF_STATEMENT  ELSE_STATEMENT  IF_STATEMENT  LOOP_LINE  LOOP_BLOCK  CONDITIONAL_LOOP_BLOCK  WHILE_STATEMENT  ARRAY_PARAM_LIST  ARRAY_PARAM  OBJECT_PARAM_ELMT  OBJECT_PARAM_LIST  OBJECT_PARAM  FOR_CONDITION  FOR_STATEMENT  PARAMETER_ELMT  PARAMETER_LIST  PARAMETER  FUNCTION  TRY_STATEMENT  ONLY_TRY_STATEMENT  CATCH_STATEMENT  FINALLY_STATEMENT  CASE_LINE  CASE_BLOCK  SWITCH_CASE  SWITCH_DEFAULT  SWITCH_BLOCK  SWITCH_STATEMENT  FUNCTION_LINE  FUNCTION_BLOCK  CODE  FUNCTION_IF_STATEMENT  FUNCTION_CONDITIONAL_BLOCK  FUNCTION_ONLY_IF_STATEMENT  FUNCTION_ELIF_STATEMENT  FUNCTION_ELSE_STATEMENT  FUNCTION_CONDITIONAL_BLOCK  FUNCTION_LOOP_LINE  FUNCTION_LOOP_BLOCK  FUNCTION_CONDITIONAL_LOOP_BLOCK  FUNCTION_WHILE_STATEMENT  FUNCTION_FOR_STATEMENT  FUNCTION_TRY_STATEMENT  FUNCTION_ONLY_TRY_STATEMENT  FUNCTION_CATCH_STATEMENT  FUNCTION_FINALLY_STATEMENT  FUNCTION_CASE_LINE  FUNCTION_CASE_BLOCK  FUNCTION_SWITCH_CASE  FUNCTION_SWITCH_DEFAULT  FUNCTION_SWITCH_BLOCK  FUNCTION_SWITCH_STATEMENT
#PRODUCTIONS
ASSIGNMENT_OP -> BLANK = BLANK  BLANK + BLANK = BLANK  BLANK - = BLANK  BLANK * = BLANK  BLANK / = BLANK  BLANK % = BLANK  BLANK * * = BLANK  BLANK < < = BLANK  BLANK > > = BLANK  BLANK > > > = BLANK  BLANK & = BLANK  BLANK ^ = BLANK  BLANK | = BLANK  BLANK & & = BLANK  BLANK | | = BLANK  BLANK ? ? = BLANK
COMPARISON_OP -> BLANK = = BLANK  BLANK ! = BLANK  BLANK = = = BLANK  BLANK ! = = BLANK  BLANK > BLANK  BLANK > = BLANK  BLANK < BLANK  BLANK < = BLANK
BINARY_ARITHMETIC_OP -> BLANK % BLANK  BLANK - BLANK  BLANK + BLANK  BLANK * * BLANK
UNARY_ARITHMETIC_OP -> BLANK + + BLANK  BLANK - - BLANK
BINARY_BITWISE_OP -> BLANK & BLANK  BLANK | BLANK  BLANK ^ BLANK  BLANK < < BLANK  BLANK < < BLANK  BLANK > > > BLANK
UNARY_BITWISE_OP -> BLANK ~ BLANK
BINARY_LOGICAL_OP -> BLANK & & BLANK  BLANK | | BLANK  COMPARISON_OP
UNARY_LOGICAL_OP -> BLANK ! BLANK
BINARY_OP -> ASSIGNMENT_OP  COMPARISON_OP  BINARY_ARITHMETIC_OP  BINARY_BITWISE_OP  BINARY_LOGICAL_OP
UNARY_OP -> UNARY_ARITHMETIC_OP  UNARY_BITWISE_OP  UNARY_LOGICAL_OP
SINGLE_INT -> 0  1  2  3  4  5  6  7  8  9
INT -> SINGLE_INT  INT INT
BIGINT -> INT n
FLOAT -> INT . INT  INT .  . INT
NUMBER -> INT  BIGINT  FLOAT
ALPHABET -> a  b  c  d  e  f  g  h  i  j  k  l  m  n  o  p  q  r  s  t  u  v  w  x  y  z  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z
PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_FORMAT -> ALPHABET  SINGLE_INT  \'  \"  \\  !  #  %  &  (  )  *  +  -  /  :  ;  <  =  >  ?  @  [  \  ]  ^  _  {  |  }  ~  €  ,  „  …  †  ‡  ˆ  ‰  Š  ‹  Œ  Ž  ‘  ’  “  ”  •  –  —  ˜  ™  š  ›  œ  ž  Ÿ  ¡  ¢  £  ¤  ¥  ¦  §  ¨  ©  ª  «  ¬  ®  ¯  °  ±  ²  ³  ´  µ  ¶  ·  ¸  ¹  º  »  ¼  ½  ¾  ¿  À  Á  Â  Ã  Ä  Å  Æ  Ç  È  É  Ê  Ë  Ì  Í  Ï  Î  Ð  Ñ  Ò  Ó  Ô  Õ  Ö  ×  Ø  Ù  Ú  Û  Ü  Ý  Þ  ß  à  á  â  ã  ä  å  æ  ç  è  é  ê  ë  ì  í  Î  ï  ð  ñ  ò  ó  ô  õ  ö  ÷  ø  ù  ú  û  ü  ý  þ  ÿ      
PRINTABLE_ASCII_WITHOUT_QUOTATION -> PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_FORMAT  $
PRINTABLE_ASCII_WITHOUT_FORMAT -> PRINTABLE_ASCII_WITHOUT_QUOTATION_AND_FORMAT  "  '
PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION -> PRINTABLE_ASCII_WITHOUT_QUOTATION  '  `
PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION -> PRINTABLE_ASCII_WITHOUT_QUOTATION  "  `
ASCII_WORD_WITHOUT_DOUBLE_QUOTATION -> PRINTABLE_ASCII_WITHOUT_DOUBLE_QUOTATION  ASCII_WORD_WITHOUT_DOUBLE_QUOTATION ASCII_WORD_WITHOUT_DOUBLE_QUOTATION
ASCII_WORD_WITHOUT_SINGLE_QUOTATION -> PRINTABLE_ASCII_WITHOUT_SINGLE_QUOTATION  ASCII_WORD_WITHOUT_SINGLE_QUOTATION ASCII_WORD_WITHOUT_SINGLE_QUOTATION
ASCII_WORD_WITHOUT_FORMAT -> PRINTABLE_ASCII_WITHOUT_FORMAT  ASCII_WORD_WITHOUT_FORMAT ASCII_WORD_WITHOUT_FORMAT
FORMAT_WORD -> ASCII_WORD_WITHOUT_FORMAT  $ { VARIABLES }  FORMAT_WORD FORMAT_WORD
DOUBLE_QUOTE_STRING -> " ASCII_WORD_WITHOUT_DOUBLE_QUOTATION "  " "
SINGLE_QUOTE_STRING -> ' ASCII_WORD_WITHOUT_SINGLE_QUOTATION '  ' '
FORMAT_STRING -> ` FORMAT_WORD `
BOOLEAN -> BLANK true BLANK  BLANK false BLANK
STRING -> DOUBLE_QUOTE_STRING  SINGLE_QUOTE_STRING  FORMAT_STRING
VARIABLES_FIRST_CHAR -> ALPHABET  _
VARIABLES_SUFIX -> NUMBER  VARIABLES_FIRST_CHAR  VARIABLES_SUFIX VARIABLES_SUFIX
VARIABLES -> VARIABLES_FIRST_CHAR  VARIABLES_FIRST_CHAR VARIABLES_SUFIX
ARRAY_LIST -> EXPRESSION  ,  EXPRESSION , ARRAY_LIST  , ARRAY_LIST
ARRAY -> BLANK [ BLANK ARRAY_LIST BLANK ] BLANK  BLANK [ BLANK ] BLANK
OBJ_ELMT -> VARIABLES  VARIABLES BLANK : BLANK EXPRESSION  VARIABLES BLANK : BLANK FUNCTION
OBJ_LIST -> OBJ_ELMT  OBJ_ELMT BLANK , BLANK  OBJ_ELMT BLANK , BLANK OBJ_LIST
OBJ -> BLANK { BLANK OBJ_ELMT BLANK } BLANK  BLANK { BLANK } BLANK
ARGUMENT_LIST -> EXPRESSION  EXPRESSION BLANK , BLANK ARGUMENT_LIST
FUNC_CALL -> VARIABLES BLANK ( BLANK ARGUMENT_LIST BLANK ) BLANK
OBJ_ATTR_CALL -> VARIABLES  VARIABLES BLANK . BLANK OBJ_ATTR_CALL
OBJ_FUNC_CALL -> OBJ_ATTR_CALL BLANK . BLANK FUNC_CALL
OBJ_CALL -> OBJ_ATTR_CALL  OBJ_FUNC_CALL
PRIMITIVE -> BOOLEAN  NUMBER  STRING  ARRAY  OBJ  null
DATA -> PRIMITIVE  VARIABLES  FUNC_CALL  OBJ_CALL
LOGICAL_EXPRESSION -> EXPRESSION  LOGICAL_EXPRESSION BINARY_LOGICAL_OP LOGICAL_EXPRESSION  UNARY_LOGICAL_OP LOGICAL_EXPRESSION
ARITHMETIC_EXPRESSION -> EXPRESSION  ARITHMETIC_EXPRESSION BINARY_ARITHMETIC_OP ARITHMETIC_EXPRESSION  ARITHMETIC_EXPRESSION BINARY_BITWISE_OP ARITHMETIC_EXPRESSION  UNARY_ARITHMETIC_OP VARIABLES  VARIABLES UNARY_ARITHMETIC_OP  UNARY_BITWISE_OP ARITHMETIC_EXPRESSION
STRING_EXPRESSION -> STRING  BLANK ( BLANK STRING_EXPRESSION BLANK ) BLANK  STRING_EXPRESSION BLANK + BLANK STRING_EXPRESSION
CONDITIONAL_EXPRESSION -> EXPRESSION BLANK ? BLANK EXPRESSION BLANK : BLANK EXPRESSION
EXPRESSION -> DATA  LOGICAL_EXPRESSION  ARITHMETIC_EXPRESSION  STRING_EXPRESSION  CONDITIONAL_EXPRESSION  ASSIGNMENT  BLANK ( BLANK EXPRESSION BLANK ) BLANK
VAR_ASSIGNMENT ->  VARIABLES ASSIGNMENT_OP EXPRESSION
OBJ_ASSIGNMENT -> OBJ_ATTR_CALL ASSIGNMENT_OP EXPRESSION
EXPRESSION_ASSIGNMENT -> EXPRESSION ASSIGNMENT_OP EXPRESSION
ASSIGNMENT -> VAR_ASSIGNMENT  OBJ_ASSIGNMENT  EXPRESSION_ASSIGNMENT
DECLARATION_KEYWORD -> BLANK let BLANK  BLANK var BLANK  BLANK const BLANK
DECLARATION -> DECLARATION_KEYWORD VARIABLES  DECLARATION_KEYWORD VARIABLES BLANK = BLANK EXPRESSION
DELETE_STATEMENT -> BLANK delete BLANK EXPRESSION
THROW_STATEMENT -> BLANK throw BLANK EXPRESSION  BLANK throw BLANK new BLANK Error BLANK ( BLANK EXPRESSION BLANK ) BLANK
RETURN_STATEMENT -> BLANK return BLANK EXPRESSION
STATEMENT -> EXPRESSION  DECLARATION  DELETE_STATEMENT  THROW_STATEMENT
LINE -> IF_STATEMENT  WHILE_STATEMENT  FOR_STATEMENT  TRY_STATEMENT  SWITCH_STATEMENT  FUNCTION  STATEMENT BLANK ;  BLANK ; BLANK
BODY_BLOCK -> LINE  BODY_BLOCK BODY_BLOCK  BLANK { BLANK BODY_BLOCK BLANK } BLANK
MULTI_LINE_COMMENT -> BLANK /* BLANK STRING BLANK */ BLANK
CONDITION -> BLANK ( BLANK EXPRESSION BLANK ) BLANK
CONDITIONAL_BLOCK -> CONDITION { BLANK BODY_BLOCK BLANK } BLANK  CONDITION LINE
ONLY_IF_STATEMENT -> if BLANK CONDITIONAL_BLOCK
ELIF_STATEMENT -> BLANK else BLANK IF_STATEMENT  ELIF_STATEMENT ELIF_STATEMENT
ELSE_STATEMENT -> BLANK else BLANK STATEMENT  BLANK else BLANK BODY_BLOCK
IF_STATEMENT -> ONLY_IF_STATEMENT  ONLY_IF_STATEMENT ELIF_STATEMENT  ONLY_IF_STATEMENT ELSE_STATEMENT  ONLY_IF_STATEMENT ELIF_STATEMENT ELSE_STATEMENT
LOOP_LINE -> LINE  BLANK break BLANK ;  BLANK continue BLANK ;
LOOP_BLOCK -> LOOP_LINE  LOOP_BLOCK LOOP_BLOCK  BLANK { BLANK LOOP_BLOCK BLANK }
CONDITIONAL_LOOP_BLOCK -> CONDITION BLANK { BLANK LOOP_BLOCK BLANK }  CONDITION LOOP_LINE
WHILE_STATEMENT -> BLANK while BLANK CONDITIONAL_LOOP_BLOCK  BLANK do BLANK LOOP_BLOCK BLANK while BLANK CONDITION  BLANK do BLANK LOOP_LINE BLANK while BLANK CONDITION
ARRAY_PARAM_LIST -> PARAMETER_ELMT  BLANK , BLANK  PARAMETER_ELMT BLANK , BLANK ARRAY_PARAM_LIST  BLANK , BLANK ARRAY_PARAM_LIST
ARRAY_PARAM -> BLANK [ BLANK ARRAY_PARAM_ELMT BLANK ] BLANK
OBJECT_PARAM_ELMT -> VARIABLES  VARIABLES BLANK : BLANK PARAMETER_ELMT
OBJECT_PARAM_LIST -> OBJECT_PARAM_ELMT  OBJECT_PARAM_ELMT BLANK , BLANK  OBJECT_PARAM_ELMT BLANK , BLANK OBJECT_PARAM_LIST
OBJECT_PARAM -> BLANK { BLANK OBJECT_PARAM_ELMT BLANK } BLANK
FOR_CONDITION -> BLANK ( BLANK EXPRESSION BLANK ; BLANK EXPRESSION BLANK ; BLANK EXPRESSION BLANK ) BLANK  BLANK ( BLANK DECLARATION BLANK ; BLANK EXPRESSION BLANK ; BLANK EXPRESSION BLANK ) BLANK
FOR_STATEMENT -> BLANK for BLANK FOR_CONDITION BODY_BLOCK
PARAMETER_ELMT -> VARIABLES  VARIABLES BLANK = BLANK EXPRESSION  VARIABLES BLANK = BLANK FUNCTION  ARRAY_PARAM  OBJECT_PARAM
PARAMETER_LIST -> PARAMETER_ELMT  PARAMETER_ELMT BLANK , BLANK PARAMETER_LIST
PARAMETER -> BLANK ( BLANK PARAMETER_LIST BLANK ) BLANK
FUNCTION -> BLANK function BLANK VARIABLES PARAMETER BLANK { BLANK FUNCTION_BLOCK BLANK } BLANK  BLANK function BLANK VARIABLES PARAMETER BLANK ;
FUNCTION_BLOCK -> FUNCTION_LINE  FUNCTION_BLOCK FUNCTION_BLOCK  BLANK { BLANK FUNCTION_BLOCK BLANK } BLANK
FUNCTION_LINE -> FUNCTION_IF_STATEMENT  FUNCTION_WHILE_STATEMENT  FUNCTION_FOR_STATEMENT  FUNCTION_TRY_STATEMENT  FUNCTION_SWITCH_STATEMENT  FUNCTION  STATEMENT BLANK ;  RETURN_STATEMENT BLANK ;  BLANK ;
TRY_STATEMENT -> ONLY_TRY_STATEMENT CATCH_STATEMENT  ONLY_TRY_STATEMENT CATCH_STATEMENT FINALLY_STATEMENT  ONLY_TRY_STATEMENT FINALLY_STATEMENT
ONLY_TRY_STATEMENT -> BLANK try BLANK { BLANK BODY_BLOCK BLANK }
CATCH_STATEMENT -> BLANK catch BLANK ( BLANK VARIABLES BLANK ) BLANK { BLANK BODY_BLOCK BLANK }  BLANK catch BLANK { BLANK BODY_BLOCK BLANK }
FINALLY_STATEMENT -> BLANK finally BLANK { BLANK BODY_BLOCK BLANK }
CASE_LINE -> LINE  BLANK break BLANK ;
CASE_BLOCK -> CASE_LINE  CASE_BLOCK CASE_BLOCK  BLANK { BLANK CASE_BLOCK BLANK }
SWITCH_CASE -> BLANK case BLANK EXPRESSION BLANK : BLANK CASE_BLOCK  SWITCH_CASE SWITCH_CASE
SWITCH_DEFAULT -> BLANK default BLANK : BLANK CASE_BLOCK
SWITCH_BLOCK -> SWITCH_CASE  SWITCH_CASE SWITCH_DEFAULT
SWITCH_STATEMENT -> BLANK switch BLANK ( BLANK EXPRESSION BLANK ) BLANK { BLANK SWITCH_BLOCK BLANK }
FUNCTION_IF_STATEMENT -> FUNCTION_ONLY_IF_STATEMENT  FUNCTION_ONLY_IF_STATEMENT FUNCTION_ELIF_STATEMENT  FUNCTION_ONLY_IF_STATEMENT FUNCTION_ELSE_STATEMENT  FUNCTION_ONLY_IF_STATEMENT FUNCTION_ELIF_STATEMENT FUNCTION_ELSE_STATEMENT
FUNCTION_CONDITIONAL_BLOCK -> CONDITION BLANK { BLANK FUNCTION_BLOCK BLANK }  CONDITION FUNCTION_LINE
FUNCTION_ONLY_IF_STATEMENT -> BLANK if BLANK FUNCTION_CONDITIONAL_BLOCK
FUNCTION_ELIF_STATEMENT -> BLANK else BLANK FUNCTION_IF_STATEMENT  FUNCTION_ELIF_STATEMENT FUNCTION_ELIF_STATEMENT
FUNCTION_ELSE_STATEMENT -> BLANK else BLANK FUNCTION_STATEMENT  BLANK else BLANK FUNCTION_BLOCK
FUNCTION_CONDITIONAL_BLOCK -> CONDITION BLANK { BLANK FUNCTION_BLOCK BLANK }  CONDITION FUNCTION_LINE
FUNCTION_LOOP_LINE -> FUNCTION_LINE  BLANK break BLANK ;  BLANK continue BLANK ;
FUNCTION_LOOP_BLOCK -> FUNCTION_LOOP_LINE  FUNCTION_LOOP_BLOCK FUNCTION_LOOP_BLOCK  BLANK { BLANK FUNCTION_LOOP_BLOCK BLANK }
FUNCTION_CONDITIONAL_LOOP_BLOCK -> CONDITION BLANK { BLANK FUNCTION_LOOP_BLOCK BLANK }  CONDITION FUNCTION_LOOP_LINE
FUNCTION_WHILE_STATEMENT -> BLANK while BLANK FUNCTION_CONDITIONAL_LOOP_BLOCK  BLANK do BLANK FUNCTION_LOOP_BLOCK BLANK while BLANK CONDITION  BLANK do BLANK FUNCTION_LOOP_LINE BLANK while BLANK CONDITION
FUNCTION_FOR_STATEMENT -> BLANK for BLANK FOR_CONDITION FUNCTION_BLOCK
FUNCTION_TRY_STATEMENT -> FUNCTION_ONLY_TRY_STATEMENT FUNCTION_CATCH_STATEMENT  FUNCTION_ONLY_TRY_STATEMENT FUNCTION_CATCH_STATEMENT FUNCTION_FINALLY_STATEMENT  FUNCTION_ONLY_TRY_STATEMENT FUNCTION_FINALLY_STATEMENT
FUNCTION_ONLY_TRY_STATEMENT -> BLANK try BLANK { BLANK FUNCTION_BLOCK BLANK }
FUNCTION_CATCH_STATEMENT -> BLANK catch BLANK ( BLANK VARIABLES BLANK ) BLANK { BLANK FUNCTION_BLOCK BLANK }  BLANK catch BLANK { BLANK FUNCTION_BLOCK BLANK }
FUNCTION_FINALLY_STATEMENT -> BLANK finally BLANK { BLANK FUNCTION_BLOCK BLANK }
FUNCTION_CASE_LINE -> FUNCTION_LINE  BLANK break BLANK ;
FUNCTION_CASE_BLOCK -> FUNCTION_CASE_LINE  FUNCTION_CASE_BLOCK FUNCTION_CASE_BLOCK  BLANK { BLANK FUNCTION_CASE_BLOCK BLANK }
FUNCTION_SWITCH_CASE -> BLANK case BLANK EXPRESSION BLANK : BLANK FUNCTION_CASE_BLOCK  FUNCTION_SWITCH_CASE FUNCTION_SWITCH_CASE
FUNCTION_SWITCH_DEFAULT -> BLANK default BLANK : BLANK FUNCTION_CASE_BLOCK
FUNCTION_SWITCH_BLOCK -> FUNCTION_SWITCH_CASE  FUNCTION_SWITCH_CASE FUNCTION_SWITCH_DEFAULT
FUNCTION_SWITCH_STATEMENT -> BLANK switch BLANK ( BLANK EXPRESSION BLANK ) BLANK { BLANK FUNCTION_SWITCH_BLOCK BLANK }
CODE -> BODY_BLOCK